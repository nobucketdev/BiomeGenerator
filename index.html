<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biome Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS variables for theme */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        :root {
            --bg-color-dark: #121212;
            --bg-color-medium: #1e1e1e;
            --bg-color-light: #2c2c2c;
            --text-color: #e0e0e0;
            --border-color: #444;
            --highlight-color: #00aaff;
            --canvas-bg: #333;
            --btn-primary: #007acc;
            --btn-primary-hover: #0088e8;
            --btn-secondary: #5a5a5a;
            --btn-secondary-hover: #6a6a6a;
            --btn-green: #4caf50;
            --btn-green-hover: #66bb6a;
            --btn-red: #f44336;
            --btn-red-hover: #e57373;
        }

        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color-dark);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            line-height: 1.5;
        }

        .container {
            background-color: var(--bg-color-medium);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            overflow: hidden;
            position: relative;
        }

        /* Canvas section */
        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 500 / 250; /* Maintain aspect ratio */
            border: 2px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        canvas {
            background-color: var(--canvas-bg);
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            transition: border-color 0.3s;
        }

        /* UI control sections */
        .ui-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            width: 100%;
            justify-content: center;
        }
        .control-section {
            background-color: var(--bg-color-light);
            padding: 20px;
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            flex-wrap: wrap;
        }

        /* Input and Button styles */
        input[type="text"] {
            background-color: var(--bg-color-medium);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px 14px;
            color: var(--text-color);
            font-size: 1rem;
            outline: none;
            flex-grow: 1;
            transition: border-color 0.2s, box-shadow 0.2s;
            min-width: 120px;
        }
        input[type="text"]:focus {
            border-color: var(--highlight-color);
            box-shadow: 0 0 0 3px rgba(0, 170, 255, 0.3);
        }
        input.invalid {
            border-color: var(--btn-red);
            box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.3);
        }
        button {
            padding: 10px 15px;
            border-radius: 6px;
            border: none;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        button:hover {
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        button:disabled {
            background-color: #555 !important;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .btn-primary { background-color: var(--btn-primary); }
        .btn-primary:hover { background-color: var(--btn-primary-hover); }
        .btn-secondary { background-color: var(--btn-secondary); }
        .btn-secondary:hover { background-color: var(--btn-secondary-hover); }
        .btn-green { background-color: var(--btn-green); }
        .btn-green:hover { background-color: var(--btn-green-hover); }
        .btn-red { background-color: var(--btn-red); }
        .btn-red:hover { background-color: var(--btn-red-hover); }
        .btn-icon {
            width: 40px;
            height: 40px;
            padding: 0;
            flex-shrink: 0;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            transition: opacity 0.3s;
        }
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--highlight-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Information and Tooltip */
        .info-text {
            font-size: 0.9rem;
            color: #999;
            text-align: center;
            width: 100%;
        }
        .tooltip {
            position: fixed;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: opacity 0.2s, transform 0.2s;
            opacity: 0;
            transform: translate(0, 10px);
        }
        .tooltip.visible {
            opacity: 1;
            transform: translate(0, 0);
        }

        /* New JS-controlled visibility class */
        .js-hidden {
            display: none !important;
        }

        /* Autocomplete List */
        #autocomplete-list {
            position: absolute;
            top: calc(100% + 5px);
            left: 0;
            right: 0;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color-medium);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            z-index: 99;
        }
        #autocomplete-list div {
            padding: 10px 14px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #autocomplete-list div:hover {
            background-color: var(--bg-color-light);
        }

        /* Matched Biomes List */
        #matchedBiomesList {
            margin-top: 15px;
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            max-height: 150px;
            overflow-y: auto;
            padding-right: 5px;
        }
        #matchedBiomesList button {
            background-color: #555;
            padding: 8px 12px;
            font-size: 0.8rem;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        #matchedBiomesList button:hover {
            background-color: #777;
        }

        /* Analysis Section */
        #analysisSection {
            width: 100%;
            border-radius: 10px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            max-height: 0;
            padding: 0 15px;
            box-sizing: border-box;
        }
        #analysisSection.expanded {
            max-height: 500px; /* Adjust as needed for content */
            padding: 15px;
        }
        #analysisSectionContent {
            background-color: var(--bg-color-light);
            padding: 20px;
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        #analysisSection h3 {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            color: var(--highlight-color);
        }
        #analysisResults {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 250px;
            overflow-y: auto;
            padding-right: 5px;
        }
        .biome-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px 15px;
            background-color: var(--bg-color-medium);
            border-radius: 8px;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .biome-stat:hover {
            background-color: #3b3b3b;
        }
        .biome-stat-name {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
        }
        .biome-color-box {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid #666;
        }
        .biome-stat-percentage {
            font-weight: bold;
            color: #b3ffb8;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-white mb-6">Procedural Biome Visualizer</h1>

        <div class="canvas-container">
            <canvas id="biomeCanvas"></canvas>
            <div id="loadingOverlay" class="loading-overlay js-hidden">
                <div class="loader"></div>
            </div>
        </div>
        
        <div class="ui-grid">
            <div class="control-section">
                <h2 class="text-xl font-semibold mb-4">Map Generation</h2>
                <div class="input-group">
                    <label for="seedInput" class="text-white sr-only">Seed</label>
                    <input type="text" id="seedInput" value="12345" placeholder="Enter a number" aria-label="Map Seed">
                    <div class="flex gap-2">
                        <button id="randomSeedButton" class="btn-primary btn-icon" title="Generate a random seed" aria-label="Generate random seed">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-dice"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><path d="M16 8h.01"/><path d="M8 16h.01"/><path d="M16 16h.01"/><path d="M8 8h.01"/><path d="M12 12h.01"/><path d="M16 12h.01"/></svg>
                        </button>
                        <button id="regenButton" class="btn-green" title="Regenerate map" aria-label="Regenerate map">Regenerate</button>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h2 class="text-xl font-semibold mb-4">Biome Search</h2>
                <div class="input-group relative">
                    <label for="findBiomeInput" class="text-white sr-only">Find Biome</label>
                    <input type="text" id="findBiomeInput" placeholder="e.g., desert" aria-label="Find Biome by Name" autocomplete="off">
                    <div id="autocomplete-list" class="autocomplete-items js-hidden"></div>
                    <div class="flex gap-2">
                        <button id="findBiomeButton" class="btn-primary btn-icon" title="Search for biome" aria-label="Search for biome">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>
                        </button>
                        <button id="clearHighlightButton" class="btn-secondary btn-icon" title="Clear biome highlight" aria-label="Clear biome highlight">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                        </button>
                    </div>
                </div>
                <div id="matchedBiomesList"></div>
            </div>
        </div>

        <button id="toggleAnalyzeButton" class="btn-secondary mt-4 mb-2" aria-expanded="false" aria-controls="analysisSection" title="Analyze map biomes">
            Analyze Map
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-bar-chart"><line x1="12" x2="12" y1="20" y2="10"/><line x1="18" x2="18" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="16"/></svg>
        </button>

        <div id="analysisSection" class="js-hidden">
            <div id="analysisSectionContent">
                <h3>Map Analysis</h3>
                <div id="analysisResults"></div>
            </div>
        </div>

        <div id="infoText" class="info-text mt-4"></div>
        <div id="tooltip" class="tooltip js-hidden"></div>
    </div>

    <script>
        // --- Perlin Noise Functions (Translated from Python) ---
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(a, b, t) { return a + t * (b - a); }
        function grad(hash_val, x, y) {
            const h = hash_val & 3;
            const u = (h & 1) === 0 ? x : -x;
            const v = (h & 2) === 0 ? y : -y;
            return u + v;
        }
        function perlin_noise(x, y, perm) {
            const xi = Math.floor(x) & 255;
            const yi = Math.floor(y) & 255;
            const xf = x - Math.floor(x);
            const yf = y - Math.floor(y);
            const u = fade(xf);
            const v = fade(yf);
            const aa = perm[perm[xi] + yi];
            const ab = perm[perm[xi] + yi + 1];
            const ba = perm[perm[xi + 1] + yi];
            const bb = perm[perm[xi + 1] + yi + 1];
            const x1 = lerp(grad(aa, xf, yf), grad(ba, xf - 1, yf), u);
            const x2 = lerp(grad(ab, xf, yf - 1), grad(bb, xf - 1, yf - 1), u);
            return (lerp(x1, x2, v) + 1) / 2;
        }
        function octave_noise(x, y, perm, octaves = 4, persistence = 0.5) {
            let total = 0.0;
            let frequency = 1.0;
            let amplitude = 1.0;
            let max_amplitude = 0.0;
            for (let i = 0; i < octaves; i++) {
                total += perlin_noise(x * frequency, y * frequency, perm) * amplitude;
                max_amplitude += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }
            return total / max_amplitude;
        }
        function generate_permutation(seed) {
            const p = Array.from({ length: 256 }, (_, i) => i);
            const rng = function(seedValue) {
                let x = Math.sin(seedValue++) * 10000;
                return function() {
                    x = Math.sin(x++) * 10000;
                    return x - Math.floor(x);
                };
            }(seed);
            for (let i = p.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [p[i], p[j]] = [p[j], p[i]];
            }
            return p.concat(p);
        }

        // --- Biome Data ---
        const BIOMES_JSON_DATA = `
{
  "biomes": [
    { "id": 999999, "name": "forbidden_island", "color": [150, 0, 50], "rules": [{ "land": "< 0.08" }], "min_distance_from_land": 30 },
    { "id": 26, "name": "island_of_fog", "color": [10, 200, 90], "rules": [{ "temp": "> 0.6" }, { "humidity": "> 0.8" }, { "height": "< 0.4" }] },
    { "id": 39, "name": "volcanic_island", "color": [80, 30, 10], "rules": [{ "temp": "> 0.8" }, { "humidity": "< 0.28" }, { "land": "< 0.23" }] },
    { "id": 38, "name": "floating_islands", "color": [200, 220, 255], "rules": [{ "height": "> 0.84" }, { "temp": "0.3..0.7" }, { "humidity": "0.4..0.7" }], "random_chance": 0.002 },
    { "id": 0, "name": "deep_ocean", "color": [0, 0, 80], "rules": [{ "land": "< 0.3" }], "water": true },
    { "id": 1, "name": "swamp", "color": [63, 84, 55], "rules": [{ "land": "0.5..0.56" }, { "humidity": "> 0.7" }], "water": true },
    { "id": 35, "name": "frozen_ocean", "color": [100, 170, 220], "rules": [{ "land": "0.4..0.56" }, { "temp": "< 0.25" }], "water": true },
    { "id": 41, "name": "lagoon", "color": [80,130,200], "rules": [{ "land": "0.5..0.56" }, { "height": "< 0.56" }], "water": true },
    { "id": 2, "name": "warm_ocean", "color": [0, 100, 200], "rules": [{ "land": "< 0.56" }, { "temp": "> 0.6" }], "water": true },
    { "id": 3, "name": "cold_ocean", "color": [0, 60, 130], "rules": [{ "land": "< 0.56" }, { "temp": "< 0.4" }], "water": true },
    { "id": 4, "name": "ocean", "color": [0, 0, 160], "rules": [{ "land": "< 0.56" }], "water": true },
    { "id": 27, "name": "frost_desert", "color": [255, 255, 180], "rules": [{ "temp": "< 0.28" }, { "humidity": "< 0.3" }, { "height": "< 0.4" }] },
    { "id": 28, "name": "crystal_forest", "color": [160, 100, 160], "rules": [{ "temp": "0.52..0.55" }, { "humidity": "0.58..0.62" }, { "height": "0.48..0.52" }] },
    { "id": 29, "name": "foggy_peak", "color": [100, 100, 150], "rules": [{ "temp": "< 0.4" }, { "humidity": "> 0.75" }, { "height": "> 0.75" }] },
    { "id": 666, "name": "corrupted_land", "color": [130, 0, 130], "rules": [{ "temp": "< 0.02" }, { "temp": "> 0.98" }, { "humidity": "< 0.02" }, { "humidity": "> 0.98" }, { "height": "< 0.02" }, { "height": "> 0.98" }], "random_chance": 0.001 },
    { "id": 8, "name": "glacier", "color": [240, 250, 255], "rules": [{ "height": "> 0.72" }, { "temp": "< 0.35" }, { "humidity": "< 0.5" }] },
    { "id": 80001, "name": "glacier#blue_ice", "base": "glacier", "color": [180, 220, 255], "rules": [{ "temp": "< 0.25" }, { "humidity": "< 0.3" }, { "height": "> 0.85" }], "random_chance": 0.05 },
    { "id": 40, "name": "meadow", "color": [150, 200, 120], "rules": [{ "height": "0.6..0.8" }, { "temp": "0.3..0.5" }, { "humidity": "0.5..0.7" }] },
    { "id": 5, "name": "snowy_mountains", "color": [255, 255, 255], "rules": [{ "height": "> 0.7" }, { "temp": "< 0.35" }] },
    { "id": 30, "name": "red_desert", "color": [180, 50, 20], "rules": [{ "temp": "> 0.72" }, { "humidity": "< 0.2" }] },
    { "id": 13, "name": "badlands", "color": [150, 70, 40], "rules": [{ "temp": "> 0.7" }, { "humidity": "< 0.28" }] },
    { "id": 31, "name": "canyonlands", "color": [160, 80, 30], "rules": [{ "height": "0.6..0.8" }, { "temp": "> 0.6" }, { "humidity": "< 0.35" }] },
    { "id": 32, "name": "maple_forest", "color": [232, 122, 22], "rules": [{ "temp": "0.45..0.6" }, { "humidity": "0.5..0.65" }, { "height": "0.3..0.6" }] },
    { "id": 34, "name": "frozen_tundra", "color": [200, 230, 250], "rules": [{ "temp": "< 0.2" }, { "humidity": "0.2..0.4" }, { "height": "0.2..0.5" }] },
    { "id": 11, "name": "desert", "color": [230, 220, 130], "rules": [{ "temp": "> 0.6" }, { "humidity": "< 0.4" }] },
    { "id": 6, "name": "plateau", "color": [200, 100, 50], "rules": [{ "height": "> 0.7" }, { "temp": "> 0.65" }] },
    { "id": 7, "name": "mountains", "color": [130, 130, 130], "rules": [{ "height": "> 0.7" }] },
    { "id": 9, "name": "tundra", "color": [180, 220, 230], "rules": [{ "temp": "< 0.35" }, { "humidity": "< 0.3" }] },
    { "id": 128, "name": "frost_land", "color": [150, 250, 240], "rules": [{ "temp": "< 0.28" }, { "humidity": "> 0.72" }] },
    { "id": 17, "name": "boreal_forest", "color": [70, 120, 100], "rules": [{ "temp": "0.35..0.4" }, { "humidity": "> 0.55" }, { "height": "> 0.4" }] },
    { "id": 10, "name": "taiga", "color": [72, 136, 153], "rules": [{ "temp": "< 0.35" }, { "humidity": "> 0.6" }] },
    { "id": 110001, "name": "desert#oasis", "base": "desert", "color": [80, 200, 120], "random_chance": 1.0, "max_distance_from_water": 3 },
    { "id": 110006, "name": "desert#salt_flat", "base": "desert", "color": [240, 240, 200], "rules": [{ "temp": ">0.5" }, { "humidity": "<0.15" }, { "height": "0.3..0.5" }], "random_chance": 0.2 },
    { "id": 122, "name": "mesa", "color": [220, 161, 93], "rules": [{ "temp": "> 0.65", "height": "0.5..0.55" }] },
    { "id": 12, "name": "savanna", "color": [220, 190, 100], "rules": [{ "temp": "> 0.6" }, { "humidity": "0.3..0.6" }] },
    { "id": 14, "name": "rainforest_hills", "color": [20, 110, 40], "rules": [{ "temp": "> 0.57" }, { "humidity": "> 0.7" }, { "height": "> 0.6" }] },
    { "id": 15, "name": "jungle", "color": [30, 160, 50], "rules": [{ "temp": "> 0.57" }, { "humidity": "> 0.7" }] },
    { "id": 16, "name": "mangrove_swamp", "color": [70, 90, 60], "rules": [{ "temp": "> 0.55" }, { "humidity": "> 0.6" }, { "height": "< 0.5" }] },
    { "id": 36, "name": "mushroom_forest", "color": [150, 80, 150], "rules": [{ "temp": "0.45..0.48" }, { "humidity": "0.6..0.8" }, { "height": "0.4..0.7" }] },
    { "id": 21, "name": "wetlands", "color": [90, 130, 90], "rules": [{ "humidity": "> 0.8" }] },
    { "id": 170009, "name": "boreal_forest#pine", "base": "boreal_forest", "color": [90, 110, 90], "rules": [{ "temp": "<0.45" }, { "humidity": "0.5..0.7" }], "random_chance": 0.25 },
    { "id": 18, "name": "temperate_forest", "color": [80, 140, 90], "rules": [{ "temp": "0.35..0.6" }, { "humidity": "> 0.5" }] },
    { "id": 19, "name": "hills", "color": [120, 170, 100], "rules": [{ "temp": "0.4..0.6" }, { "humidity": "0.4..0.6" }, { "height": "> 0.55" }] },
    { "id": 200101, "name": "plains#flower_field", "color": [180, 255, 180], "rules": [{ "humidity": "> 0.5" }, { "temp": "0.42..0.65" }] },
    { "id": 22, "name": "plains#shrubland", "color": [130, 180, 90], "rules": [{ "temp": "0.48..0.6" }, { "humidity": "0.3..0.42" }] },
    { "id": 129, "name": "plains#desolate", "color": [124, 209, 173], "rules": [{ "temp": "< 0.28" }] },
    { "id": 20, "name": "plains", "color": [110, 190, 90], "rules": [{ "height": "0.3..0.6" }] },
    { "id": 994, "name": "bleak_plains", "color": [158, 168, 136], "rules": [{ "height": "> 0.65" }] },
    { "id": 995, "name": "plains#low_land", "color": [121, 168, 115], "rules": [{ "height": "< 0.35" }] },
    { "id": 999, "name": "coast", "color": [240, 230, 180], "rules": [] }
  ]
}
        `;

        const BIOME_DATA = JSON.parse(BIOMES_JSON_DATA);
        const BIOME_IDS = {};
        const BIOME_NAMES = {};
        const BIOME_COLORS = new Map();
        const WATER_BIOME_IDS = new Set();
        const NO_COAST_BIOME_IDS = new Set();
        let WATER_BIOME_IDS_WITH_COAST = new Set();

        BIOME_DATA.biomes.forEach(b => {
            BIOME_IDS[b.name] = b.id;
            BIOME_NAMES[b.id] = b.name;
            BIOME_COLORS.set(b.id, b.color);
            if (b.water) {
                WATER_BIOME_IDS.add(b.id);
            }
            if (b.name === "deep_ocean" || b.name === "frozen_ocean" || b.name === "swamp_ocean") {
                NO_COAST_BIOME_IDS.add(b.id);
            }
        });

        WATER_BIOME_IDS_WITH_COAST = new Set([...WATER_BIOME_IDS].filter(id => !NO_COAST_BIOME_IDS.has(id)));

        const base_biomes = [];
        const variant_biomes = [];

        function parseCondition(expr) {
            expr = expr.trim();
            if (expr.includes("..")) {
                const [lo, hi] = expr.split("..").map(Number);
                return v => v >= lo && v <= hi;
            } else if (expr.startsWith(">=")) {
                const val = parseFloat(expr.substring(2));
                return v => v >= val;
            } else if (expr.startsWith("<=")) {
                const val = parseFloat(expr.substring(2));
                return v => v <= val;
            } else if (expr.startsWith(">")) {
                const val = parseFloat(expr.substring(1));
                return v => v > val;
            } else if (expr.startsWith("<")) {
                const val = parseFloat(expr.substring(1));
                return v => v < val;
            } else if (expr.startsWith("==")) {
                const val = parseFloat(expr.substring(2));
                return v => v === val;
            } else {
                const val = parseFloat(expr);
                return v => v === val;
            }
        }

        BIOME_DATA.biomes.forEach(b => {
            const rule_funcs = [];
            if (b.rules) {
                b.rules.forEach(rule => {
                    for (const key in rule) {
                        rule_funcs.push([key, parseCondition(rule[key])]);
                    }
                });
            }
            const record = {
                id: b.id,
                name: b.name,
                rules: rule_funcs,
                random_chance: b.random_chance || 0
            };
            if (b.base) {
                record.base = b.base;
                if (b.max_distance_from_water !== undefined) { record.max_distance_from_water = b.max_distance_from_water; }
                if (b.min_distance_from_land !== undefined) { record.min_distance_from_land = b.min_distance_from_land; }
                variant_biomes.push(record);
            } else {
                base_biomes.push(record);
            }
        });

        function biome_to_color(biome_id) {
            return BIOME_COLORS.get(biome_id) || [0, 0, 0];
        }

        // --- Biome Generation Logic ---
        function classify_biome_fast(land, temp, humidity, height) {
            height = (land + height * 2) / 2.72;
            land = (land * 2 + height) / 2.72;
            const env = { "land": land, "temp": temp, "humidity": humidity, "height": height };
            for (const b of base_biomes) {
                if (b.rules.every(([key, rule]) => rule(env[key]))) {
                    if (b.random_chance === 0 || Math.random() < b.random_chance) {
                        return b.id;
                    }
                }
            }
            return BIOME_IDS["plains"];
        }

        function calculate_distance_from_land(land_map, width, height) {
            const dist_map = Array(width).fill(0).map(() => Array(height).fill(Infinity));
            const queue = [];
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    if (land_map[x][y]) {
                        dist_map[x][y] = 0;
                        queue.push({ x, y });
                    }
                }
            }
            let head = 0;
            while (head < queue.length) {
                const { x, y } = queue[head++];
                const current_dist = dist_map[x][y];
                const neighbors = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]];
                for (const [nx, ny] of neighbors) {
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        if (dist_map[nx][ny] > current_dist + 1) {
                            dist_map[nx][ny] = current_dist + 1;
                            queue.push({ x: nx, y: ny });
                        }
                    }
                }
            }
            return dist_map;
        }

        function is_water_within_distance(biome_map, x, y, max_dist, width, height) {
            for (let dx = -max_dist; dx <= max_dist; dx++) {
                for (let dy = -max_dist; dy <= max_dist; dy++) {
                    if (dx * dx + dy * dy > max_dist * max_dist) { continue; }
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        if (WATER_BIOME_IDS.has(biome_map[nx][ny])) { return true; }
                    }
                }
            }
            return false;
        }

        function apply_biome_variants(biome_map, temp_map, humidity_map, height_noise_map, land_map, variants, dist_map, map_width, map_height, rng) {
            const new_map = biome_map.map(arr => [...arr]);
            for (let x = 0; x < map_width; x++) {
                for (let y = 0; y < map_height; y++) {
                    const base_id = biome_map[x][y];
                    const base_name = BIOME_NAMES[base_id];
                    if (!base_name) { continue; }
                    for (const var_b of variants) {
                        if (var_b.base !== base_name) { continue; }
                        const env = {
                            "temp": temp_map[x][y],
                            "humidity": humidity_map[x][y],
                            "height": height_noise_map[x][y],
                            "land": land_map[x][y]
                        };
                        if (!var_b.rules.every(([key, rule]) => rule(env[key]))) { continue; }
                        if (var_b.max_distance_from_water !== undefined && !is_water_within_distance(biome_map, x, y, var_b.max_distance_from_water, map_width, map_height)) { continue; }
                        if (var_b.min_distance_from_land !== undefined && dist_map && dist_map[x][y] < var_b.min_distance_from_land) { continue; }
                        if (var_b.random_chance < 1 && rng() > var_b.random_chance) { continue; }
                        new_map[x][y] = var_b.id;
                        break;
                    }
                }
            }
            return new_map;
        }

        function spread_jungle_and_mangrove(biome_map, temp, humidity, height, width, height_map) {
            const new_map = biome_map.map(arr => [...arr]);
            const JUNGLE = BIOME_IDS["jungle"];
            const MANGROVE_SWAMP = BIOME_IDS["mangrove_swamp"];
            for (let x = 1; x < width - 1; x++) {
                for (let y = 1; y < height_map - 1; y++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            const b = biome_map[nx][ny];
                            if (b === JUNGLE || b === MANGROVE_SWAMP) {
                                if (temp[x][y] > 0.5 && humidity[x][y] > 0.6 && height[x][y] < 0.55) {
                                    new_map[x][y] = b;
                                }
                            }
                        }
                    }
                }
            }
            return new_map;
        }

        function spread_corrupted_land(biome_map, width, height_map, iterations = 4) {
            let current_map = biome_map.map(arr => [...arr]);
            const CORRUPTED_LAND = BIOME_IDS["corrupted_land"];
            for (let iter = 0; iter < iterations; iter++) {
                const next_map = current_map.map(arr => [...arr]);
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height_map; y++) {
                        if (current_map[x][y] === CORRUPTED_LAND) {
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height_map && (dx !== 0 || dy !== 0)) {
                                        next_map[nx][ny] = CORRUPTED_LAND;
                                    }
                                }
                            }
                        }
                    }
                }
                current_map = next_map;
            }
            return current_map;
        }

        function generate_biome_map_fast(land, temp, humidity, height, width, height_map, rng) {
            const biome_map = Array(width).fill(0).map(() => Array(height_map).fill(0));
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height_map; y++) {
                    biome_map[x][y] = classify_biome_fast(land[x][y], temp[x][y], humidity[x][y], height[x][y]);
                }
            }
            const land_bool_map = land.map(col => col.map(val => val > 0.5));
            const dist_map = calculate_distance_from_land(land_bool_map, width, height_map);
            const COAST = BIOME_IDS["coast"];
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height_map; y++) {
                    if (WATER_BIOME_IDS.has(biome_map[x][y])) { continue; }
                    let has_water_neighbor = false;
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height_map) {
                                if (WATER_BIOME_IDS_WITH_COAST.has(biome_map[nx][ny])) {
                                    has_water_neighbor = true;
                                    break;
                                }
                            }
                        }
                        if (has_water_neighbor) break;
                    }
                    if (has_water_neighbor) { biome_map[x][y] = COAST; }
                }
            }
            let current_biome_map = spread_jungle_and_mangrove(biome_map, temp, humidity, height, width, height_map);
            current_biome_map = spread_corrupted_land(current_biome_map, width, height_map);
            current_biome_map = apply_biome_variants(current_biome_map, temp, humidity, height, land, variant_biomes, dist_map, width, height_map, rng);
            return current_biome_map;
        }

        // --- Main Application Logic ---
        const WIDTH = 500;
        const HEIGHT = 250;
        const canvas = document.getElementById('biomeCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        const seedInput = document.getElementById('seedInput');
        const randomSeedButton = document.getElementById('randomSeedButton');
        const regenButton = document.getElementById('regenButton');
        const toggleAnalyzeButton = document.getElementById('toggleAnalyzeButton');
        const findBiomeInput = document.getElementById('findBiomeInput');
        const findBiomeButton = document.getElementById('findBiomeButton');
        const clearHighlightButton = document.getElementById('clearHighlightButton');
        const infoText = document.getElementById('infoText');
        const tooltipDiv = document.getElementById('tooltip');
        const matchedBiomesList = document.getElementById('matchedBiomesList');
        const analysisSection = document.getElementById('analysisSection');
        const analysisResults = document.getElementById('analysisResults');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const autocompleteList = document.getElementById('autocomplete-list');
        let currentSeed;
        let maps = {};
        let foundTiles = [];
        let searchBiomeName = null;
        let lastMouseTile = { x: -1, y: -1 };
        let allBiomeNames = Object.values(BIOME_NAMES).filter((v, i, a) => a.indexOf(v) === i).sort();

        function createSeededRandom(seedValue) {
            let x = Math.sin(seedValue++) * 10000;
            return function() { x = Math.sin(x++) * 10000; return x - Math.floor(x); };
        }

        function generate_map(seed, scale, width, height) {
            const perm = generate_permutation(seed);
            const data = Array(width).fill(0).map(() => Array(height).fill(0));
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    const nx = x / scale;
                    const ny = y / scale;
                    data[x][y] = octave_noise(nx, ny, perm);
                }
            }
            let min_val = Infinity;
            let max_val = -Infinity;
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    if (data[x][y] < min_val) min_val = data[x][y];
                    if (data[x][y] > max_val) max_val = data[x][y];
                }
            }
            if (max_val - min_val === 0) { return Array(width).fill(0).map(() => Array(height).fill(0.5)); }
            const normalized_data = Array(width).fill(0).map(() => Array(height).fill(0));
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    normalized_data[x][y] = (data[x][y] - min_val) / (max_val - min_val);
                }
            }
            return normalized_data;
        }

        function regenerate(seed) {
            console.log(`Generating map with seed: ${seed}`);
            loadingOverlay.classList.remove('js-hidden');
            regenButton.disabled = true;
            randomSeedButton.disabled = true;
            findBiomeButton.disabled = true;
            clearHighlightButton.disabled = true;
            toggleAnalyzeButton.disabled = true;
            findBiomeInput.disabled = true;
            seedInput.disabled = true;

            return new Promise(resolve => {
                setTimeout(() => {
                    const rng = createSeededRandom(seed);
                    const land = generate_map(seed + 1876, 48, WIDTH, HEIGHT);
                    const temp = generate_map(seed + 2345, 64, WIDTH, HEIGHT);
                    const humidity = generate_map(seed + 3234, 64, WIDTH, HEIGHT);
                    const height = generate_map(seed + 4098, 24, WIDTH, HEIGHT);
                    const biome = generate_biome_map_fast(land, temp, humidity, height, WIDTH, HEIGHT, rng);
                    
                    loadingOverlay.classList.add('js-hidden');
                    regenButton.disabled = false;
                    randomSeedButton.disabled = false;
                    findBiomeButton.disabled = false;
                    clearHighlightButton.disabled = false;
                    toggleAnalyzeButton.disabled = false;
                    findBiomeInput.disabled = false;
                    seedInput.disabled = false;
                    resolve({ land: land, temp: temp, humidity: humidity, height: height, biome: biome });
                }, 100);
            });
        }

        function drawBiomeMap(biomeMap) {
            const imageData = ctx.createImageData(WIDTH, HEIGHT);
            for (let x = 0; x < WIDTH; x++) {
                for (let y = 0; y < HEIGHT; y++) {
                    const color = biome_to_color(biomeMap[x][y]);
                    const index = (y * WIDTH + x) * 4;
                    imageData.data[index] = color[0];
                    imageData.data[index + 1] = color[1];
                    imageData.data[index + 2] = color[2];
                    imageData.data[index + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function findBiomeTiles(biomeMap, targetBiomeId) {
            const tiles = [];
            for (let x = 0; x < WIDTH; x++) {
                for (let y = 0; y < HEIGHT; y++) {
                    if (biomeMap[x][y] === targetBiomeId) {
                        tiles.push({ x, y });
                    }
                }
            }
            return tiles;
        }

        function updateInfoText() {
            let text = `Current Seed: ${currentSeed}`;
            if (searchBiomeName) {
                text += ` | Biome highlighted: ${searchBiomeName} (${foundTiles.length} tiles)`;
            }
            infoText.textContent = text;
        }

        function clearMatchedBiomesList() {
            matchedBiomesList.innerHTML = '';
        }
        
        function updateUrlWithSeed(seed) {
            const url = new URL(window.location);
            url.searchParams.set('seed', seed);
            window.history.pushState({ seed: seed }, '', url.toString());
        }

        function analyzeMap() {
            const biomeCounts = {};
            const totalPixels = WIDTH * HEIGHT;
            for (let x = 0; x < WIDTH; x++) {
                for (let y = 0; y < HEIGHT; y++) {
                    const biomeId = maps.biome[x][y];
                    biomeCounts[biomeId] = (biomeCounts[biomeId] || 0) + 1;
                }
            }
            const sortedBiomes = Object.entries(biomeCounts)
                .map(([id, count]) => {
                    const biomeId = parseInt(id);
                    const name = BIOME_NAMES[biomeId] || `Unknown Biome ID: ${biomeId}`;
                    const percentage = (count / totalPixels) * 100;
                    const color = biome_to_color(biomeId);
                    return { id: biomeId, name, percentage, color, count };
                })
                .sort((a, b) => b.count - a.count);
            analysisResults.innerHTML = '';
            sortedBiomes.forEach(biome => {
                const statDiv = document.createElement('div');
                statDiv.className = 'biome-stat';
                statDiv.addEventListener('click', () => {
                    findBiomeInput.value = biome.name;
                    findBiomeButton.click();
                });
                const nameDiv = document.createElement('div');
                nameDiv.className = 'biome-stat-name';
                const colorBox = document.createElement('span');
                colorBox.className = 'biome-color-box';
                colorBox.style.backgroundColor = `rgb(${biome.color[0]}, ${biome.color[1]}, ${biome.color[2]})`;
                nameDiv.appendChild(colorBox);
                nameDiv.appendChild(document.createTextNode(biome.name));
                const percentageSpan = document.createElement('span');
                percentageSpan.className = 'biome-stat-percentage';
                percentageSpan.textContent = `${biome.percentage.toFixed(2)}%`;
                statDiv.appendChild(nameDiv);
                statDiv.appendChild(percentageSpan);
                analysisResults.appendChild(statDiv);
            });
            analysisSection.classList.add('expanded');
            toggleAnalyzeButton.setAttribute('aria-expanded', 'true');
        }
        
        function toggleAnalysisSection() {
            const isExpanded = analysisSection.classList.toggle('expanded');
            toggleAnalyzeButton.setAttribute('aria-expanded', isExpanded);
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const urlSeed = urlParams.get('seed');
            if (urlSeed && !isNaN(parseInt(urlSeed))) {
                currentSeed = parseInt(urlSeed);
                seedInput.value = currentSeed;
            } else {
                currentSeed = parseInt(seedInput.value);
                updateUrlWithSeed(currentSeed);
            }
            regenerate(currentSeed).then(newMaps => {
                maps = newMaps;
                drawBiomeMap(maps.biome);
                updateInfoText();
            });
        });

        regenButton.addEventListener('click', () => {
            const seedValue = parseInt(seedInput.value);
            if (!isNaN(seedValue)) {
                currentSeed = seedValue;
                regenerate(currentSeed).then(newMaps => {
                    maps = newMaps;
                    drawBiomeMap(maps.biome);
                    foundTiles = [];
                    searchBiomeName = null;
                    updateInfoText();
                    clearMatchedBiomesList();
                    analysisSection.classList.remove('expanded');
                    toggleAnalyzeButton.setAttribute('aria-expanded', 'false');
                    updateUrlWithSeed(currentSeed);
                });
                seedInput.classList.remove('invalid');
            } else {
                console.warn("Invalid seed. Please enter an integer.");
                seedInput.classList.add('invalid');
            }
        });

        randomSeedButton.addEventListener('click', () => {
            const randomSeed = Math.floor(Math.random() * 999999);
            seedInput.value = randomSeed;
            seedInput.classList.remove('invalid');
            currentSeed = randomSeed;
            regenerate(currentSeed).then(newMaps => {
                maps = newMaps;
                drawBiomeMap(maps.biome);
                foundTiles = [];
                searchBiomeName = null;
                updateInfoText();
                clearMatchedBiomesList();
                analysisSection.classList.remove('expanded');
                toggleAnalyzeButton.setAttribute('aria-expanded', 'false');
                updateUrlWithSeed(currentSeed);
            });
        });

        toggleAnalyzeButton.addEventListener('click', toggleAnalysisSection);

        findBiomeInput.addEventListener('input', () => {
            const input = findBiomeInput.value.toLowerCase();
            autocompleteList.innerHTML = '';
            if (!input) {
                autocompleteList.classList.add('js-hidden');
                return;
            }
            const matches = allBiomeNames.filter(name => name.toLowerCase().includes(input));
            if (matches.length > 0) {
                autocompleteList.classList.remove('js-hidden');
                matches.forEach(name => {
                    const item = document.createElement('div');
                    item.textContent = name;
                    item.addEventListener('click', () => {
                        findBiomeInput.value = name;
                        autocompleteList.classList.add('js-hidden');
                        findBiomeButton.click();
                    });
                    autocompleteList.appendChild(item);
                });
            } else {
                autocompleteList.classList.add('js-hidden');
            }
        });

        document.addEventListener('click', (event) => {
            if (!event.target.closest('.input-group')) {
                autocompleteList.classList.add('js-hidden');
            }
        });

        findBiomeButton.addEventListener('click', () => {
            const inputName = findBiomeInput.value.toLowerCase();
            const matched = Object.entries(BIOME_NAMES)
                                .filter(([, name]) => name.toLowerCase().includes(inputName))
                                .map(([id, name]) => ({ id: parseInt(id), name }));
            clearMatchedBiomesList();
            if (matched.length === 1) {
                const { id, name } = matched[0];
                searchBiomeName = name;
                foundTiles = findBiomeTiles(maps.biome, id);
                updateInfoText();
                console.log(`Found ${foundTiles.length} tiles for biome: ${name}`);
            } else if (matched.length > 1) {
                searchBiomeName = null;
                foundTiles = [];
                matched.forEach(biome => {
                    const button = document.createElement('button');
                    button.textContent = biome.name;
                    button.classList.add('btn-secondary');
                    button.addEventListener('click', () => {
                        searchBiomeName = biome.name;
                        foundTiles = findBiomeTiles(maps.biome, biome.id);
                        updateInfoText();
                        clearMatchedBiomesList();
                        findBiomeInput.value = biome.name;
                    });
                    matchedBiomesList.appendChild(button);
                });
                infoText.textContent = "Multiple matches found. Select from the list below:";
            } else {
                searchBiomeName = null;
                foundTiles = [];
                infoText.textContent = "Biome not found.";
            }
            updateInfoText();
        });

        clearHighlightButton.addEventListener('click', () => {
            foundTiles = [];
            searchBiomeName = null;
            updateInfoText();
        });

        // "What biome is this?" feature: Tooltip on mousemove
        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((event.clientX - rect.left) * scaleX);
            const y = Math.floor((event.clientY - rect.top) * scaleY);

            if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {
                if (x !== lastMouseTile.x || y !== lastMouseTile.y) {
                    lastMouseTile = { x, y };
                    const biomeId = maps.biome[x][y];
                    const biomeName = BIOME_NAMES[biomeId] || "unknown";
                    const tempVal = maps.temp[x][y];
                    const humidVal = maps.humidity[x][y];
                    const heightVal = maps.height[x][y];
                    const infoText = `${biomeName} | Temp:${tempVal.toFixed(2)} Humid:${humidVal.toFixed(2)} Height:${heightVal.toFixed(2)}`;
                    tooltipDiv.textContent = infoText;
                    tooltipDiv.classList.remove('js-hidden');
                    tooltipDiv.classList.add('visible');
                    
                    // Position tooltip near the cursor
                    const offsetX = 15, offsetY = 15;
                    let tooltipX = event.clientX + offsetX;
                    let tooltipY = event.clientY + offsetY;
                    const tooltipRect = tooltipDiv.getBoundingClientRect();
                    if (tooltipX + tooltipRect.width > window.innerWidth) {
                        tooltipX = event.clientX - tooltipRect.width - offsetX;
                    }
                    if (tooltipY + tooltipRect.height > window.innerHeight) {
                        tooltipY = event.clientY - tooltipRect.height - offsetY;
                    }
                    tooltipDiv.style.left = `${tooltipX}px`;
                    tooltipDiv.style.top = `${tooltipY}px`;
                }
            } else {
                // Hide tooltip when cursor is outside the canvas
                tooltipDiv.classList.add('js-hidden');
                tooltipDiv.classList.remove('visible');
                lastMouseTile = { x: -1, y: -1 };
            }
        });

        canvas.addEventListener('mouseleave', () => {
            tooltipDiv.classList.add('js-hidden');
            tooltipDiv.classList.remove('visible');
            lastMouseTile = { x: -1, y: -1 };
        });

        // Animation loop for highlights
        let lastHighlightTime = 0;
        function animate(currentTime) {
            if (!lastHighlightTime) lastHighlightTime = currentTime;
            const deltaTime = currentTime - lastHighlightTime;
            
            if (foundTiles.length > 0) {
                drawBiomeMap(maps.biome);
                const alpha = Math.floor((Math.sin(currentTime / 200) + 1) / 2 * 180 + 75);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha / 255})`;
                for (const { x, y } of foundTiles) {
                    ctx.fillRect(x, y, 1, 1);
                }
            } else if (searchBiomeName !== null) {
                drawBiomeMap(maps.biome);
                searchBiomeName = null;
            }
            lastHighlightTime = currentTime;
            requestAnimationFrame(animate);
        }

        // Start the animation loop
        requestAnimationFrame(animate);
    </script>
</body>
</html>
