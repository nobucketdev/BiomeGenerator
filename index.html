<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biome Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        /* Using CSS variables for better maintainability */
        :root {
            --bg-color-dark: #1a1a1a;
            --bg-color-medium: #2a2a2a;
            --bg-color-light: #3b3b3b;
            --text-color: #e0e0e0;
            --border-color: #555;
            --highlight-color: #70a3ff;
            --canvas-bg: #333;
            --btn-blue: #4a90e2;
            --btn-blue-hover: #5a9cec;
            --btn-blue-active: #3a7bd8;
            --btn-green: #5cb85c;
            --btn-green-hover: #6bcc6b;
            --btn-green-active: #4aa44a;
            --btn-red: #d9534f;
            --btn-red-hover: #e06662;
            --btn-red-active: #c0403c;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color-dark);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: var(--bg-color-medium);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--canvas-bg);
            image-rendering: pixelated; /* For sharper pixel art if needed */
            width: 100%; /* Make canvas responsive */
            max-width: 500px; /* Max width for the map */
            height: auto;
            cursor: crosshair; /* Improved cursor for interaction */
            transition: border-color 0.3s;
        }
        canvas.loading {
            border-color: var(--highlight-color);
        }
        .ui-section {
            display: flex;
            flex-wrap: wrap;
            gap: 20px; /* Increased gap */
            margin-top: 20px;
            justify-content: center;
            width: 100%;
        }
        /* Grouping related input elements */
        .input-group, .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-section {
            background-color: var(--bg-color-light);
            padding: 15px;
            border-radius: 8px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        input[type="text"] {
            background-color: var(--bg-color-light);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 8px 12px;
            color: var(--text-color);
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        input[type="text"]:focus {
            border-color: var(--highlight-color);
            box-shadow: 0 0 0 2px rgba(112, 163, 255, 0.5);
        }
        input.invalid {
            border-color: var(--btn-red);
            box-shadow: 0 0 0 2px rgba(217, 83, 79, 0.5);
        }
        button {
            padding: 10px 15px;
            border-radius: 5px;
            border: none;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        button:hover {
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        .btn-blue {
            background-color: var(--btn-blue);
        }
        .btn-blue:hover {
            background-color: var(--btn-blue-hover);
        }
        .btn-blue:active {
            background-color: var(--btn-blue-active);
        }
        .btn-green {
            background-color: var(--btn-green);
        }
        .btn-green:hover {
            background-color: var(--btn-green-hover);
        }
        .btn-green:active {
            background-color: var(--btn-green-active);
        }
        .btn-red {
            background-color: var(--btn-red);
        }
        .btn-red:hover {
            background-color: var(--btn-red-hover);
        }
        .btn-red:active {
            background-color: var(--btn-red-active);
        }
        .btn-icon {
            padding: 8px; /* Smaller padding for icon button */
            width: 38px; /* Fixed width for consistent size */
            height: 38px;
        }
        .info-text {
            margin-top: 20px;
            font-size: 0.9rem;
            color: #bbb;
            text-align: center;
            width: 100%;
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.85); /* Slightly darker background */
            color: white;
            padding: 6px 10px; /* Slightly more padding */
            border-radius: 6px; /* Smoother corners */
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: opacity 0.2s, transform 0.2s;
            opacity: 0;
            transform: translate(0, 5px);
        }
        .tooltip.visible {
            opacity: 1;
            transform: translate(0, 0);
        }
        /* New styles for matched biomes list */
        #matchedBiomesList {
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
            width: 100%;
            max-width: 600px;
            background-color: var(--bg-color-light);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }
        #matchedBiomesList button {
            background-color: #555;
            padding: 6px 10px;
            font-size: 0.85rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        #matchedBiomesList button:hover {
            background-color: #777;
        }
        /* Styles for the new analysis section */
        #analysisSection {
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
            background-color: var(--bg-color-light);
            border-radius: 8px;
            padding: 15px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
            display: none; /* Hidden by default */
        }
        #analysisSection h3 {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        #analysisResults {
            display: flex;
            flex-direction: column; /* Changed to column for list format */
            gap: 8px;
            max-height: 250px;
            overflow-y: auto;
            padding-right: 5px;
        }
        .biome-stat {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 6px 10px;
            background-color: #444;
            border-radius: 5px;
            align-items: center;
        }
        .biome-stat-name {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .biome-color-box {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            border: 1px solid #666;
        }
        .biome-stat-percentage {
            font-weight: bold;
            color: #a0ffaa;
        }
        .loader {
            display: none; /* Hidden by default */
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--highlight-color);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #autocomplete-list {
            position: absolute;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color-medium);
            border-top: none;
            z-index: 99;
            width: 100%;
            max-width: 250px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border-radius: 0 0 8px 8px;
        }
        #autocomplete-list div {
            padding: 10px;
            cursor: pointer;
            background-color: var(--bg-color-light);
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.2s;
        }
        #autocomplete-list div:hover {
            background-color: var(--bg-color-medium);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-2xl font-bold mb-4">Biome Visualizer</h1>
        <canvas id="biomeCanvas"></canvas>
        <div id="loadingIndicator" class="loader mt-4"></div>
        <div class="ui-section">
            <div class="control-section">
                <h2 class="text-lg font-semibold mb-2 text-center">Map Generation</h2>
                <div class="input-group">
                    <label for="seedInput" class="text-white">Seed:</label>
                    <input type="text" id="seedInput" value="12345" placeholder="Enter a number" aria-label="Map Seed">
                    <button id="randomSeedButton" class="btn-blue btn-icon" aria-label="Generate random seed">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-dice"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><path d="M16 8h.01"/><path d="M8 16h.01"/><path d="M16 16h.01"/><path d="M8 8h.01"/><path d="M12 12h.01"/><path d="M16 12h.01"/></svg>
                    </button>
                    <button id="regenButton" class="btn-blue" aria-label="Regenerate map">Regenerate</button>
                </div>
            </div>

            <div class="control-section">
                <h2 class="text-lg font-semibold mb-2 text-center">Biome Search</h2>
                <div class="input-group relative">
                    <label for="findBiomeInput" class="text-white">Find Biome:</label>
                    <input type="text" id="findBiomeInput" placeholder="e.g., desert" aria-label="Find Biome by Name" autocomplete="off">
                    <div id="autocomplete-list" class="autocomplete-items hidden"></div>
                    <button id="findBiomeButton" class="btn-green" aria-label="Search for biome">Find</button>
                    <button id="clearHighlightButton" class="btn-red" aria-label="Clear biome highlight">Clear Highlight</button>
                </div>
                <div id="matchedBiomesList"></div>
            </div>
        </div>
        
        <button id="analyzeButton" class="btn-green mt-4" aria-label="Analyze map biomes">Analyze Map</button>

        <div id="analysisSection">
            <h3>Map Analysis</h3>
            <div id="analysisResults"></div>
        </div>
        
        <div id="infoText" class="info-text"></div>
        <div id="tooltip" class="tooltip hidden"></div>
    </div>

    <script>
        // --- Perlin Noise Functions (Translated from Python) ---
        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        function lerp(a, b, t) {
            return a + t * (b - a);
        }

        function grad(hash_val, x, y) {
            const h = hash_val & 3;
            const u = (h & 1) === 0 ? x : -x;
            const v = (h & 2) === 0 ? y : -y;
            return u + v;
        }

        function perlin_noise(x, y, perm) {
            const xi = Math.floor(x) & 255;
            const yi = Math.floor(y) & 255;
            const xf = x - Math.floor(x);
            const yf = y - Math.floor(y);
            const u = fade(xf);
            const v = fade(yf);

            const aa = perm[perm[xi] + yi];
            const ab = perm[perm[xi] + yi + 1];
            const ba = perm[perm[xi + 1] + yi];
            const bb = perm[perm[xi + 1] + yi + 1];

            const x1 = lerp(grad(aa, xf, yf), grad(ba, xf - 1, yf), u);
            const x2 = lerp(grad(ab, xf, yf - 1), grad(bb, xf - 1, yf - 1), u);

            return (lerp(x1, x2, v) + 1) / 2;
        }

        function octave_noise(x, y, perm, octaves = 4, persistence = 0.5) {
            let total = 0.0;
            let frequency = 1.0;
            let amplitude = 1.0;
            let max_amplitude = 0.0;

            for (let i = 0; i < octaves; i++) {
                total += perlin_noise(x * frequency, y * frequency, perm) * amplitude;
                max_amplitude += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }
            return total / max_amplitude;
        }

        function generate_permutation(seed) {
            const p = Array.from({ length: 256 }, (_, i) => i);
            // Simple seeded random number generator for permutation
            const rng = function(seedValue) {
                let x = Math.sin(seedValue++) * 10000;
                return function() {
                    x = Math.sin(x++) * 10000;
                    return x - Math.floor(x);
                };
            }(seed); // Immediately invoke to create the seeded random function

            for (let i = p.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [p[i], p[j]] = [p[j], p[i]];
            }
            return p.concat(p);
        }

        // --- Biome Data (Translated from Python) ---
        const BIOMES_JSON_DATA = `
{
  "biomes": [
    {
  "id": 999999,
  "name": "forbidden_island",
  "color": [150, 0, 50],
  "rules": [
    {
      "land": "< 0.08"
    }
  ],
  "min_distance_from_land": 30
    },
    {
      "id": 26,
      "name": "island_of_fog",
      "color": [10, 200, 90],
      "rules": [
        {
          "temp": "> 0.6"
        },
        {
          "humidity": "> 0.8"
        },
        {
          "height": "< 0.4"
        }
      ]
    },
    {
      "id": 39,
      "name": "volcanic_island",
      "color": [80, 30, 10],
      "rules": [
        {
          "temp": "> 0.8"
        },
        {
          "humidity": "< 0.28"
        },
        {
          "land": "< 0.23"
        }
      ]
    },
    {
      "id": 38,
      "name": "floating_islands",
      "color": [200, 220, 255],
      "rules": [
        {
          "height": "> 0.84"
        },
        {
          "temp": "0.3..0.7"
        },
        {
          "humidity": "0.4..0.7"
        }
      ],
      "random_chance": 0.002
    },
    {
      "id": 0,
      "name": "deep_ocean",
      "color": [0, 0, 80],
      "rules": [
        {
          "land": "< 0.3"
        }
      ],
      "water": true
    },
    {
      "id": 1,
      "name": "swamp",
      "color": [63, 84, 55],
      "rules": [
        {
          "land": "0.5..0.56"
        },
        {
          "humidity": "> 0.7"
        }
      ],
      "water": true
    },
    {
      "id": 35,
      "name": "frozen_ocean",
      "color": [100, 170, 220],
      "rules": [
        {
          "land": "0.4..0.56"
        },
        {
          "temp": "< 0.25"
        }
      ],
      "water": true
    },

    {
      "id": 41,
      "name": "lagoon",
      "color": [80,130,200],
      "rules": [
        {
          "land": "0.5..0.56"
        },
        {
          "height": "< 0.56"
        }
      ],
      "water": true
    },

    {
      "id": 2,
      "name": "warm_ocean",
      "color": [0, 100, 200],
      "rules": [
        {
          "land": "< 0.56"
        },
        {
          "temp": "> 0.6"
        }
      ],
      "water": true
    },
    {
      "id": 3,
      "name": "cold_ocean",
      "color": [0, 60, 130],
      "rules": [
        {
          "land": "< 0.56"
        },
        {
          "temp": "< 0.4"
        }
      ],
      "water": true
    },
    {
      "id": 4,
      "name": "ocean",
      "color": [0, 0, 160],
      "rules": [
        {
          "land": "< 0.56"
        }
      ],
      "water": true
    },
    {
      "id": 27,
      "name": "frost_desert",
      "color": [255, 255, 180],
      "rules": [
        {
          "temp": "< 0.28"
        },
        {
          "humidity": "< 0.3"
        },
        {
          "height": "< 0.4"
        }
      ]
    },
    {
      "id": 28,
      "name": "crystal_forest",
      "color": [160, 100, 160],
      "rules": [
        {
          "temp": "0.52..0.55"
        },
        {
          "humidity": "0.58..0.62"
        },
        {
          "height": "0.48..0.52"
        }
      ]
    },
    {
      "id": 29,
      "name": "foggy_peak",
      "color": [100, 100, 150],
      "rules": [
        {
          "temp": "< 0.4"
        },
        {
          "humidity": "> 0.75"
        },
        {
          "height": "> 0.75"
        }
      ]
    },
    {
      "id": 666,
      "name": "corrupted_land",
      "color": [130, 0, 130],
      "rules": [
        {
          "temp": "< 0.02"
        },
        {
          "temp": "> 0.98"
        },
        {
          "humidity": "< 0.02"
        },
        {
          "humidity": "> 0.98"
        },
        {
          "height": "< 0.02"
        },
        {
          "height": "> 0.98"
        }
      ],
      "random_chance": 0.001
    },
    {
      "id": 8,
      "name": "glacier",
      "color": [240, 250, 255],
      "rules": [
        {
          "height": "> 0.72"
        },
        {
          "temp": "< 0.35"
        },
        {
          "humidity": "< 0.5"
        }
      ]
    },
    {
      "id": 80001,
      "name": "glacier#blue_ice",
      "base": "glacier",
      "color": [180, 220, 255],
      "rules": [
        {
          "temp": "< 0.25"
        },
        {
          "humidity": "< 0.3"
        },
        {
          "height": "> 0.85"
        }
      ],
      "random_chance": 0.05
    },
    {
      "id": 40,
      "name": "meadow",
      "color": [150, 200, 120],
      "rules": [
        {
          "height": "0.6..0.8"
        },
        {
          "temp": "0.3..0.5"
        },
        {
          "humidity": "0.5..0.7"
        }
      ]
    },
    {
      "id": 5,
      "name": "snowy_mountains",
      "color": [255, 255, 255],
      "rules": [
        {
          "height": "> 0.7"
        },
        {
          "temp": "< 0.35"
        }
      ]
    },
    {
      "id": 30,
      "name": "red_desert",
      "color": [180, 50, 20],
      "rules": [
        {
          "temp": "> 0.72"
        },
        {
          "humidity": "< 0.2"
        }
      ]
    },
        {
      "id": 13,
      "name": "badlands",
      "color": [150, 70, 40],
      "rules": [
        {
          "temp": "> 0.7"
        },
        {
          "humidity": "< 0.28"
        }
      ]
    },
    {
      "id": 31,
      "name": "canyonlands",
      "color": [160, 80, 30],
      "rules": [
        {
          "height": "0.6..0.8"
        },
        {
          "temp": "> 0.6"
        },
        {
          "humidity": "< 0.35"
        }
      ]
    },
    {
      "id": 32,
      "name": "maple_forest",
      "color": [232, 122, 22],
      "rules": [
        {
          "temp": "0.45..0.6"
        },
        {
          "humidity": "0.5..0.65"
        },
        {
          "height": "0.3..0.6"
        }
      ]
    },
    {
      "id": 34,
      "name": "frozen_tundra",
      "color": [200, 230, 250],
      "rules": [
        {
          "temp": "< 0.2"
        },
        {
          "humidity": "0.2..0.4"
        },
        {
          "height": "0.2..0.5"
        }
      ]
    },
    {
      "id": 11,
      "name": "desert",
      "color": [230, 220, 130],
      "rules": [
        {
          "temp": "> 0.6"
        },
        {
          "humidity": "< 0.4"
        }
      ]
    },
    {
      "id": 6,
      "name": "plateau",
      "color": [200, 100, 50],
      "rules": [
        {
          "height": "> 0.7"
        },
        {
          "temp": "> 0.65"
        }
      ]
    },
    {
      "id": 7,
      "name": "mountains",
      "color": [130, 130, 130],
      "rules": [
        {
          "height": "> 0.7"
        }
      ]
    },
    {
      "id": 9,
      "name": "tundra",
      "color": [180, 220, 230],
      "rules": [
        {
          "temp": "< 0.35"
        },
        {
          "humidity": "< 0.3"
        }
      ]
    },
    {
      "id": 128,
      "name": "frost_land",
      "color": [150, 250, 240],
      "rules": [
        {
          "temp": "< 0.28"
        },
        {
          "humidity": "> 0.72"
        }
      ]
    },
    {
      "id": 17,
      "name": "boreal_forest",
      "color": [70, 120, 100],
      "rules": [
        {
          "temp": "0.35..0.4"
        },
        {
          "humidity": "> 0.55"
        },
        {
          "height": "> 0.4"
        }
      ]
    },
    {
      "id": 10,
      "name": "taiga",
      "color": [72, 136, 153],
      "rules": [
        {
          "temp": "< 0.35"
        },
        {
          "humidity": "> 0.6"
        }
      ]
    },
    {
      "id": 110001,
      "name": "desert#oasis",
      "base": "desert",
      "color": [80, 200, 120],
      "random_chance": 1.0,
      "max_distance_from_water": 3
    },
    {
      "id": 110006,
      "name": "desert#salt_flat",
      "base": "desert",
      "color": [240, 240, 200],
      "rules": [
        {
          "temp": ">0.5"
        },
        {
          "humidity": "<0.15"
        },
        {
          "height": "0.3..0.5"
        }
      ],
      "random_chance": 0.2
    },
    {
      "id": 13,
      "name": "badlands",
      "color": [150, 70, 40],
      "rules": [
        {
          "temp": "> 0.7"
        },
        {
          "humidity": "< 0.28"
        }
      ]
    },
    {
      "id": 122,
      "name": "mesa",
      "color": [
        220,
        161,
        93
      ],
      "rules": [
        {
          "temp": "> 0.65",
          "height": "0.5..0.55"
        }
      ]
    },
    {
      "id": 12,
      "name": "savanna",
      "color": [220, 190, 100],
      "rules": [
        {
          "temp": "> 0.6"
        },
        {
          "humidity": "0.3..0.6"
        }
      ]
    },
    {
      "id": 14,
      "name": "rainforest_hills",
      "color": [20, 110, 40],
      "rules": [
        {
          "temp": "> 0.57"
        },
        {
          "humidity": "> 0.7"
        },
        {
          "height": "> 0.6"
        }
      ]
    },
    {
      "id": 15,
      "name": "jungle",
      "color": [30, 160, 50],
      "rules": [
        {
          "temp": "> 0.57"
        },
        {
          "humidity": "> 0.7"
        }
      ]
    },
    {
      "id": 16,
      "name": "mangrove_swamp",
      "color": [70, 90, 60],
      "rules": [
        {
          "temp": "> 0.55"
        },
        {
          "humidity": "> 0.6"
        },
        {
          "height": "< 0.5"
        }
      ]
    },
    {
      "id": 36,
      "name": "mushroom_forest",
      "color": [150, 80, 150],
      "rules": [
        {
          "temp": "0.45..0.48"
        },
        {
          "humidity": "0.6..0.8"
        },
        {
          "height": "0.4..0.7"
        }
      ]
    },
    {
      "id": 21,
      "name": "wetlands",
      "color": [90, 130, 90],
      "rules": [
        {
          "humidity": "> 0.8"
        }
      ]
    },
    {
      "id": 170009,
      "name": "boreal_forest#pine",
      "base": "boreal_forest",
      "color": [90, 110, 90],
      "rules": [
        {
          "temp": "<0.45"
        },
        {
          "humidity": "0.5..0.7"
        }
      ],
      "random_chance": 0.25
    },
    {
      "id": 18,
      "name": "temperate_forest",
      "color": [80, 140, 90],
      "rules": [
        {
          "temp": "0.35..0.6"
        },
        {
          "humidity": "> 0.5"
        }
      ]
    },
    {
      "id": 19,
      "name": "hills",
      "color": [120, 170, 100],
      "rules": [
        {
          "temp": "0.4..0.6"
        },
        {
          "humidity": "0.4..0.6"
        },
        {
          "height": "> 0.55"
        }
      ]
    },
    {
      "id": 200101,
      "name": "plains#flower_field",
      "color": [180, 255, 180],
      "rules": [
        {
          "humidity": "> 0.5"
        },
        {
          "temp": "0.42..0.65"
        }
      ]
    },
    {
      "id": 22,
      "name": "plains#shrubland",
      "color": [130, 180, 90],
      "rules": [
        {
          "temp": "0.48..0.6"
        },
        {
          "humidity": "0.3..0.42"
        }
      ]
    },
    {
      "id": 129,
      "name": "plains#desolate",
      "color": [124, 209, 173],
      "rules": [
        {
          "temp": "< 0.28"
        }
      ]
    },
    {
      "id": 20,
      "name": "plains",
      "color": [110, 190, 90],
      "rules": [
        {
          "height": "0.3..0.6"
        }
      ]
    },
    {
      "id": 994,
      "name": "bleak_plains",
      "color": [158, 168, 136],
      "rules": [
        {
          "height": "> 0.65"
        }
      ]
    },
    {
      "id": 995,
      "name": "plains#low_land",
      "color": [121, 168, 115],
      "rules": [
        {
          "height": "< 0.35"
        }
      ]
    },
    {
      "id": 999,
      "name": "coast",
      "color": [240, 230, 180],
      "rules": []
    }
  ]
}
        `;

        const BIOME_DATA = JSON.parse(BIOMES_JSON_DATA);
        const BIOME_IDS = {};
        const BIOME_NAMES = {};
        const BIOME_COLORS = new Map();
        const WATER_BIOME_IDS = new Set();
        const NO_COAST_BIOME_IDS = new Set();
        let WATER_BIOME_IDS_WITH_COAST = new Set();

        BIOME_DATA.biomes.forEach(b => {
            BIOME_IDS[b.name] = b.id;
            BIOME_NAMES[b.id] = b.name;
            BIOME_COLORS.set(b.id, b.color);
            if (b.water) {
                WATER_BIOME_IDS.add(b.id);
            }
            if (b.name === "deep_ocean" || b.name === "frozen_ocean" || b.name === "swamp_ocean") {
                NO_COAST_BIOME_IDS.add(b.id);
            }
        });

        WATER_BIOME_IDS_WITH_COAST = new Set([...WATER_BIOME_IDS].filter(id => !NO_COAST_BIOME_IDS.has(id)));

        const base_biomes = [];
        const variant_biomes = [];

        function parseCondition(expr) {
            expr = expr.trim();
            if (expr.includes("..")) {
                const [lo, hi] = expr.split("..").map(Number);
                return v => v >= lo && v <= hi;
            } else if (expr.startsWith(">=")) {
                const val = parseFloat(expr.substring(2));
                return v => v >= val;
            } else if (expr.startsWith("<=")) {
                const val = parseFloat(expr.substring(2));
                return v => v <= val;
            } else if (expr.startsWith(">")) {
                const val = parseFloat(expr.substring(1));
                return v => v > val;
            } else if (expr.startsWith("<")) {
                const val = parseFloat(expr.substring(1));
                return v => v < val;
            } else if (expr.startsWith("==")) {
                const val = parseFloat(expr.substring(2));
                return v => v === val;
            } else {
                const val = parseFloat(expr);
                return v => v === val;
            }
        }

        BIOME_DATA.biomes.forEach(b => {
            const rule_funcs = [];
            if (b.rules) {
                b.rules.forEach(rule => {
                    for (const key in rule) {
                        rule_funcs.push([key, parseCondition(rule[key])]);
                    }
                });
            }
            const record = {
                id: b.id,
                name: b.name,
                rules: rule_funcs,
                random_chance: b.random_chance || 0
            };
            if (b.base) {
                record.base = b.base;
                if (b.max_distance_from_water !== undefined) {
                    record.max_distance_from_water = b.max_distance_from_water;
                }
                if (b.min_distance_from_land !== undefined) {
                    record.min_distance_from_land = b.min_distance_from_land;
                }
                variant_biomes.push(record);
            } else {
                base_biomes.push(record);
            }
        });

        function biome_to_color(biome_id) {
            return BIOME_COLORS.get(biome_id) || [0, 0, 0]; // Default to black if not found
        }

        // --- Biome Generation Logic (Translated from Python) ---

        function classify_biome_fast(land, temp, humidity, height) {
            height = (land + height * 2) / 2.72;
            land = (land * 2 + height) / 2.72;

            const env = {
                "land": land,
                "temp": temp,
                "humidity": humidity,
                "height": height
            };

            for (const b of base_biomes) {
                if (b.rules.every(([key, rule]) => rule(env[key]))) {
                    // This random check should also use the seeded RNG
                    // The seeded RNG instance will be passed down from generate_biome_map_fast
                    // For now, we'll assume it's available in the scope or passed.
                    // This function doesn't directly use Math.random(), so no change here.
                    if (b.random_chance === 0 || Math.random() < b.random_chance) { // This still uses Math.random()
                        return b.id;
                    }
                }
            }
            return BIOME_IDS["plains"];
        }

        // Simple Euclidean Distance Transform (approximation for this context)
        function calculate_distance_from_land(land_map, width, height) {
            const dist_map = Array(width).fill(0).map(() => Array(height).fill(Infinity));
            const queue = [];

            // Initialize distances for land cells
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    if (land_map[x][y]) { // If it's land
                        dist_map[x][y] = 0;
                        queue.push({ x, y });
                    }
                }
            }

            let head = 0;
            while (head < queue.length) {
                const { x, y } = queue[head++];
                const current_dist = dist_map[x][y];

                // Neighbors
                const neighbors = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]];
                for (const [nx, ny] of neighbors) {
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        if (dist_map[nx][ny] > current_dist + 1) {
                            dist_map[nx][ny] = current_dist + 1;
                            queue.push({ x: nx, y: ny });
                        }
                    }
                }
            }
            return dist_map;
        }

        function is_water_within_distance(biome_map, x, y, max_dist, width, height) {
            for (let dx = -max_dist; dx <= max_dist; dx++) {
                for (let dy = -max_dist; dy <= max_dist; dy++) {
                    if (dx * dx + dy * dy > max_dist * max_dist) {
                        continue;
                    }
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        if (WATER_BIOME_IDS.has(biome_map[nx][ny])) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Renamed parameters for clarity:
        // height -> height_noise_map (the noise map for height)
        // width -> map_width (the dimension of the map)
        // height -> map_height (the dimension of the map)
        function apply_biome_variants(biome_map, temp_map, humidity_map, height_noise_map, land_map, variants, dist_map, map_width, map_height, rng) {
            const new_map = biome_map.map(arr => [...arr]); // Deep copy

            for (let x = 0; x < map_width; x++) {
                for (let y = 0; y < map_height; y++) {
                    const base_id = biome_map[x][y];
                    const base_name = BIOME_NAMES[base_id];
                    if (!base_name) {
                        continue;
                    }

                    for (const var_b of variants) {
                        if (var_b.base !== base_name) {
                            continue;
                        }

                        const env = {
                            "temp": temp_map[x][y],
                            "humidity": humidity_map[x][y],
                            "height": height_noise_map[x][y], // Correctly using the noise map
                            "land": land_map[x][y]
                        };

                        if (!var_b.rules.every(([key, rule]) => rule(env[key]))) {
                            continue;
                        }

                        if (var_b.max_distance_from_water !== undefined) {
                            if (!is_water_within_distance(biome_map, x, y, var_b.max_distance_from_water, map_width, map_height)) {
                                continue;
                            }
                        }

                        if (var_b.min_distance_from_land !== undefined && dist_map) {
                            if (dist_map[x][y] < var_b.min_distance_from_land) {
                                continue;
                            }
                        }

                        if (var_b.random_chance < 1 && rng() > var_b.random_chance) { // Use seeded RNG here
                            continue;
                        }

                        new_map[x][y] = var_b.id;
                        break;
                    }
                }
            }
            return new_map;
        }

        function spread_jungle_and_mangrove(biome_map, temp, humidity, height, width, height_map) {
            const new_map = biome_map.map(arr => [...arr]);
            const JUNGLE = BIOME_IDS["jungle"];
            const MANGROVE_SWAMP = BIOME_IDS["mangrove_swamp"];

            for (let x = 1; x < width - 1; x++) {
                for (let y = 1; y < height_map - 1; y++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            const b = biome_map[nx][ny];
                            if (b === JUNGLE || b === MANGROVE_SWAMP) {
                                if (temp[x][y] > 0.5 && humidity[x][y] > 0.6 && height[x][y] < 0.55) {
                                    new_map[x][y] = b;
                                }
                            }
                        }
                    }
                }
            }
            return new_map;
        }

        function spread_corrupted_land(biome_map, width, height_map, iterations = 4) {
            let current_map = biome_map.map(arr => [...arr]);
            const CORRUPTED_LAND = BIOME_IDS["corrupted_land"];

            for (let iter = 0; iter < iterations; iter++) {
                const next_map = current_map.map(arr => [...arr]);
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height_map; y++) {
                        if (current_map[x][y] === CORRUPTED_LAND) {
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height_map && (dx !== 0 || dy !== 0)) {
                                        next_map[nx][ny] = CORRUPTED_LAND;
                                    }
                                }
                            }
                        }
                    }
                }
                current_map = next_map;
            }
            return current_map;
        }

        function generate_biome_map_fast(land, temp, humidity, height, width, height_map, rng) {
            const biome_map = Array(width).fill(0).map(() => Array(height_map).fill(0));

            // Step 1: Base biome classification
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height_map; y++) {
                    // Pass the rng to classify_biome_fast if it needs to use random_chance
                    // For now, classify_biome_fast uses Math.random() directly, which is still a potential issue.
                    // If classify_biome_fast also needs to use the seeded random, it needs to be passed down.
                    // For this change, we're focusing on apply_biome_variants and future uses.
                    biome_map[x][y] = classify_biome_fast(
                        land[x][y], temp[x][y], humidity[x][y], height[x][y]
                    );
                }
            }

            // Calculate distance from land (for forbidden_island)
            const land_bool_map = land.map(col => col.map(val => val > 0.5)); // Assuming land if value > 0.5
            const dist_map = calculate_distance_from_land(land_bool_map, width, height_map);

            // Step 2: Coastlines
            const COAST = BIOME_IDS["coast"];
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height_map; y++) {
                    if (WATER_BIOME_IDS.has(biome_map[x][y])) {
                        continue;
                    }

                    let has_water_neighbor = false;
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height_map) {
                                if (WATER_BIOME_IDS_WITH_COAST.has(biome_map[nx][ny])) {
                                    has_water_neighbor = true;
                                    break;
                                }
                            }
                        }
                        if (has_water_neighbor) break;
                    }

                    if (has_water_neighbor) {
                        biome_map[x][y] = COAST;
                    }
                }
            }

            // Step 3: Spreads
            let current_biome_map = spread_jungle_and_mangrove(biome_map, temp, humidity, height, width, height_map);
            current_biome_map = spread_corrupted_land(current_biome_map, width, height_map);

            // Step 4: Apply variants (oasis, forbidden_island, etc)
            current_biome_map = apply_biome_variants(
                current_biome_map, temp, humidity, height, land, // Pass the noise maps
                variant_biomes, dist_map, width, height_map, rng // Pass the dimensions and RNG
            );

            return current_biome_map;
        }

        // --- Main Application Logic ---
        const WIDTH = 500;
        const HEIGHT = 250;

        const canvas = document.getElementById('biomeCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        const seedInput = document.getElementById('seedInput');
        const randomSeedButton = document.getElementById('randomSeedButton');
        const regenButton = document.getElementById('regenButton');
        const analyzeButton = document.getElementById('analyzeButton');
        const findBiomeInput = document.getElementById('findBiomeInput');
        const findBiomeButton = document.getElementById('findBiomeButton');
        const clearHighlightButton = document.getElementById('clearHighlightButton');
        const infoText = document.getElementById('infoText');
        const tooltipDiv = document.getElementById('tooltip');
        const matchedBiomesList = document.getElementById('matchedBiomesList');
        const analysisSection = document.getElementById('analysisSection');
        const analysisResults = document.getElementById('analysisResults');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const autocompleteList = document.getElementById('autocomplete-list');

        let currentSeed;
        let maps = {};
        let foundTiles = [];
        let searchBiomeName = null;
        let lastMouseTile = { x: -1, y: -1 };
        let allBiomeNames = Object.values(BIOME_NAMES).filter((v, i, a) => a.indexOf(v) === i).sort(); // Get unique sorted biome names for autocomplete

        // Helper for seeded random numbers (a simple implementation)
        // This function creates and returns a seeded random number generator.
        // It's a self-contained closure to ensure the seed is private to the generator.
        function createSeededRandom(seedValue) {
            let x = Math.sin(seedValue++) * 10000;
            return function() {
                x = Math.sin(x++) * 10000;
                return x - Math.floor(x);
            };
        }


        function generate_map(seed, scale, width, height) {
            const perm = generate_permutation(seed);
            const data = Array(width).fill(0).map(() => Array(height).fill(0));

            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    const nx = x / scale;
                    const ny = y / scale;
                    data[x][y] = octave_noise(nx, ny, perm);
                }
            }

            // Normalize to 0-1
            let min_val = Infinity;
            let max_val = -Infinity;
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    if (data[x][y] < min_val) min_val = data[x][y];
                    if (data[x][y] > max_val) max_val = data[x][y];
                }
            }

            if (max_val - min_val === 0) {
                return Array(width).fill(0).map(() => Array(height).fill(0.5));
            }

            const normalized_data = Array(width).fill(0).map(() => Array(height).fill(0));
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    normalized_data[x][y] = (data[x][y] - min_val) / (max_val - min_val);
                }
            }
            return normalized_data;
        }

        function regenerate(seed) {
            console.log(`Generating map with seed: ${seed}`);
            loadingIndicator.style.display = 'block'; // Show loading indicator
            canvas.classList.add('loading');
            regenButton.disabled = true;

            return new Promise(resolve => {
                setTimeout(() => { // Use a timeout to allow the loading indicator to render
                    // Create a single RNG instance for the entire map generation process
                    const rng = createSeededRandom(seed);

                    const land = generate_map(seed + 1876, 48, WIDTH, HEIGHT);
                    const temp = generate_map(seed + 2345, 64, WIDTH, HEIGHT);
                    const humidity = generate_map(seed + 3234, 64, WIDTH, HEIGHT);
                    const height = generate_map(seed + 4098, 24, WIDTH, HEIGHT);
                    // Pass the rng instance to generate_biome_map_fast
                    const biome = generate_biome_map_fast(land, temp, humidity, height, WIDTH, HEIGHT, rng);

                    loadingIndicator.style.display = 'none'; // Hide loading indicator
                    canvas.classList.remove('loading');
                    regenButton.disabled = false;
                    resolve({
                        land: land,
                        temp: temp,
                        humidity: humidity,
                        height: height,
                        biome: biome
                    });
                }, 100); // Small delay to show the loader
            });
        }

        function drawBiomeMap(biomeMap) {
            const imageData = ctx.createImageData(WIDTH, HEIGHT);
            for (let x = 0; x < WIDTH; x++) {
                for (let y = 0; y < HEIGHT; y++) {
                    const color = biome_to_color(biomeMap[x][y]);
                    const index = (y * WIDTH + x) * 4;
                    imageData.data[index] = color[0];
                    imageData.data[index + 1] = color[1];
                    imageData.data[index + 2] = color[2];
                    imageData.data[index + 3] = 255; // Alpha
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function findBiomeTiles(biomeMap, targetBiomeId) {
            const tiles = [];
            for (let x = 0; x < WIDTH; x++) {
                for (let y = 0; y < HEIGHT; y++) {
                    if (biomeMap[x][y] === targetBiomeId) {
                        tiles.push({ x, y });
                    }
                }
            }
            return tiles;
        }

        function updateInfoText() {
            let text = `Current Seed: ${currentSeed}`;
            if (searchBiomeName) {
                text += ` | Biome highlighted: ${searchBiomeName} (${foundTiles.length} tiles)`;
            }
            infoText.textContent = text;
        }

        function clearMatchedBiomesList() {
            while (matchedBiomesList.firstChild) {
                matchedBiomesList.removeChild(matchedBiomesList.firstChild);
            }
        }
        
        function updateUrlWithSeed(seed) {
            const url = new URL(window.location);
            url.searchParams.set('seed', seed);
            window.history.pushState({ seed: seed }, '', url.toString());
        }

        function analyzeMap() {
            const biomeCounts = {};
            const totalPixels = WIDTH * HEIGHT;
            
            // Count pixels for each biome
            for (let x = 0; x < WIDTH; x++) {
                for (let y = 0; y < HEIGHT; y++) {
                    const biomeId = maps.biome[x][y];
                    biomeCounts[biomeId] = (biomeCounts[biomeId] || 0) + 1;
                }
            }
            
            // Calculate percentages and sort by count (desc)
            const sortedBiomes = Object.entries(biomeCounts)
                .map(([id, count]) => {
                    const biomeId = parseInt(id);
                    const name = BIOME_NAMES[biomeId] || `Unknown Biome ID: ${biomeId}`;
                    const percentage = (count / totalPixels) * 100;
                    const color = biome_to_color(biomeId);
                    return { name, percentage, color, count };
                })
                .sort((a, b) => b.count - a.count); // Sort by pixel count, descending
                
            // Display results
            analysisResults.innerHTML = '';
            sortedBiomes.forEach(biome => {
                const statDiv = document.createElement('div');
                statDiv.className = 'biome-stat';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'biome-stat-name';
                
                const colorBox = document.createElement('span');
                colorBox.className = 'biome-color-box';
                colorBox.style.backgroundColor = `rgb(${biome.color[0]}, ${biome.color[1]}, ${biome.color[2]})`;
                
                nameDiv.appendChild(colorBox);
                nameDiv.appendChild(document.createTextNode(biome.name));
                
                const percentageSpan = document.createElement('span');
                percentageSpan.className = 'biome-stat-percentage';
                percentageSpan.textContent = `${biome.percentage.toFixed(2)}%`;
                
                statDiv.appendChild(nameDiv);
                statDiv.appendChild(percentageSpan);
                
                analysisResults.appendChild(statDiv);
            });
            
            // Show the analysis section
            analysisSection.style.display = 'block';
        }

        // Initialize currentSeed from URL, then input, then default
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const urlSeed = urlParams.get('seed');

            if (urlSeed && !isNaN(parseInt(urlSeed))) {
                currentSeed = parseInt(urlSeed);
                seedInput.value = currentSeed;
            } else {
                currentSeed = parseInt(seedInput.value);
                updateUrlWithSeed(currentSeed);
            }

            regenerate(currentSeed).then(newMaps => {
                maps = newMaps;
                drawBiomeMap(maps.biome);
                updateInfoText();
            });
        });


        // Event Listeners
        regenButton.addEventListener('click', () => {
            const seedValue = parseInt(seedInput.value);
            if (!isNaN(seedValue)) {
                currentSeed = seedValue;
                regenerate(currentSeed).then(newMaps => {
                    maps = newMaps;
                    drawBiomeMap(maps.biome);
                    foundTiles = [];
                    searchBiomeName = null;
                    updateInfoText();
                    clearMatchedBiomesList();
                    analysisSection.style.display = 'none';
                    updateUrlWithSeed(currentSeed);
                });
                seedInput.classList.remove('invalid'); // Remove error state
            } else {
                console.warn("Invalid seed. Please enter an integer.");
                seedInput.classList.add('invalid'); // Add error state
            }
        });

        // Event listener for the new random seed button
        randomSeedButton.addEventListener('click', () => {
            const randomSeed = Math.floor(Math.random() * 999999);
            seedInput.value = randomSeed;
            seedInput.classList.remove('invalid');
            currentSeed = randomSeed;
            regenerate(currentSeed).then(newMaps => {
                maps = newMaps;
                drawBiomeMap(maps.biome);
                foundTiles = [];
                searchBiomeName = null;
                updateInfoText();
                clearMatchedBiomesList();
                analysisSection.style.display = 'none';
                updateUrlWithSeed(currentSeed);
            });
        });

        analyzeButton.addEventListener('click', () => {
            analyzeMap();
        });

        // Autocomplete functionality
        findBiomeInput.addEventListener('input', () => {
            const input = findBiomeInput.value.toLowerCase();
            autocompleteList.innerHTML = '';
            if (!input) {
                autocompleteList.classList.add('hidden');
                return;
            }

            const matches = allBiomeNames.filter(name => name.toLowerCase().includes(input));
            
            if (matches.length > 0) {
                autocompleteList.classList.remove('hidden');
                matches.forEach(name => {
                    const item = document.createElement('div');
                    item.textContent = name;
                    item.addEventListener('click', () => {
                        findBiomeInput.value = name;
                        autocompleteList.classList.add('hidden');
                        // Trigger the find biome logic
                        findBiomeButton.click();
                    });
                    autocompleteList.appendChild(item);
                });
            } else {
                autocompleteList.classList.add('hidden');
            }
        });

        // Hide autocomplete when clicking outside
        document.addEventListener('click', (event) => {
            if (!event.target.closest('.input-group')) {
                autocompleteList.classList.add('hidden');
            }
        });

        findBiomeButton.addEventListener('click', () => {
            const inputName = findBiomeInput.value.toLowerCase();
            const matched = Object.entries(BIOME_NAMES)
                                .filter(([, name]) => name.toLowerCase().includes(inputName))
                                .map(([id, name]) => ({ id: parseInt(id), name }));

            clearMatchedBiomesList();

            if (matched.length === 1) {
                const { id, name } = matched[0];
                searchBiomeName = name;
                foundTiles = findBiomeTiles(maps.biome, id);
                updateInfoText();
                console.log(`Found ${foundTiles.length} tiles for biome: ${name}`);
            } else if (matched.length > 1) {
                searchBiomeName = null;
                foundTiles = [];

                matched.forEach(biome => {
                    const button = document.createElement('button');
                    button.textContent = biome.name;
                    button.classList.add('btn-blue');
                    button.addEventListener('click', () => {
                        searchBiomeName = biome.name;
                        foundTiles = findBiomeTiles(maps.biome, biome.id);
                        updateInfoText();
                        clearMatchedBiomesList();
                        findBiomeInput.value = biome.name; // Update input field
                    });
                    matchedBiomesList.appendChild(button);
                });
                infoText.textContent = `Multiple matches found. Select from the list below:`;
            } else {
                searchBiomeName = null;
                foundTiles = [];
                infoText.textContent = "Biome not found.";
            }
            updateInfoText();
        });

        clearHighlightButton.addEventListener('click', () => {
            foundTiles = [];
            searchBiomeName = null;
            updateInfoText();
            drawBiomeMap(maps.biome);
            clearMatchedBiomesList();
        });

        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = Math.floor((event.clientX - rect.left) * scaleX);
            const y = Math.floor((event.clientY - rect.top) * scaleY);

            if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {
                if (x !== lastMouseTile.x || y !== lastMouseTile.y) {
                    lastMouseTile = { x, y };

                    const biomeId = maps.biome[x][y];
                    const biomeName = BIOME_NAMES[biomeId] || "unknown";
                    const tempVal = maps.temp[x][y];
                    const humidVal = maps.humidity[x][y];
                    const heightVal = maps.height[x][y];

                    const infoText = `${biomeName} | T:${tempVal.toFixed(2)} H:${humidVal.toFixed(2)} Z:${heightVal.toFixed(2)}`;
                    tooltipDiv.textContent = infoText;
                    tooltipDiv.classList.add('visible');

                    // Position tooltip
                    tooltipDiv.style.left = `${event.clientX + 10}px`;
                    tooltipDiv.style.top = `${event.clientY + 10}px`;

                    // Adjust position if it goes off screen
                    const tooltipRect = tooltipDiv.getBoundingClientRect();
                    if (tooltipRect.right > window.innerWidth) {
                        tooltipDiv.style.left = `${event.clientX - tooltipRect.width - 10}px`;
                    }
                    if (tooltipRect.bottom > window.innerHeight) {
                        tooltipDiv.style.top = `${event.clientY - tooltipRect.height - 10}px`;
                    }
                }
            } else {
                tooltipDiv.classList.remove('visible');
                lastMouseTile = { x: -1, y: -1 };
            }
        });

        canvas.addEventListener('mouseleave', () => {
            tooltipDiv.classList.remove('visible');
            lastMouseTile = { x: -1, y: -1 };
        });

        // Animation loop for highlights
        let lastHighlightTime = 0;
        function animate(currentTime) {
            if (!lastHighlightTime) lastHighlightTime = currentTime;
            const deltaTime = currentTime - lastHighlightTime;

            if (foundTiles.length > 0) {
                // Redraw the base map first to clear previous highlights
                drawBiomeMap(maps.biome);

                // Smooth glowing white highlight on found biome tiles
                const alpha = Math.floor((Math.sin(currentTime / 200) + 1) / 2 * 180 + 75); // range: 75-255

                ctx.fillStyle = `rgba(255, 255, 255, ${alpha / 255})`;
                for (const { x, y } of foundTiles) {
                    ctx.fillRect(x, y, 1, 1);
                }
            } else {
                // If no tiles are highlighted, ensure the map is drawn without highlights
                drawBiomeMap(maps.biome);
            }
            lastHighlightTime = currentTime;
            requestAnimationFrame(animate);
        }

        // Start the animation loop
        requestAnimationFrame(animate);

    </script>
</body>
</html>
